<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Coursera PML Project</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Coursera PML Project</h1>

<p>This project focuses on building a Machine Learning model of user activity performance using multiple accelerometer measurements. I explain my thought process using machine learning concepts.</p>

<p>The purpose of this model is to correctly classify new observations.</p>

<h2>Loading and Cleaning Data</h2>

<pre><code class="r">options(warn=-1)

dataset &lt;- read.table(&#39;data/pml-training.csv&#39;, 
                      sep = &#39;,&#39;, 
                      header = TRUE, 
                      stringsAsFactors = FALSE, 
                      na.strings = c(&#39;&#39;,&#39;NA&#39;,&#39;#DIV/0!&#39;))

# Table of Complete (No NA Values) vs Incomplete Rows (At least 1 NA Value)
table(complete.cases(dataset))
</code></pre>

<pre><code>## 
## FALSE 
## 19622
</code></pre>

<pre><code class="r"># Number of Columns with X% of NA Values
colNAs &lt;- colSums(is.na(dataset))
percents&lt;- table(colNAs/nrow(dataset))
percentNames &lt;- round(as.numeric(names(percents))*100,2)
percentNames &lt;- paste0(percentNames,&#39;%&#39;)
names(percents) &lt;- percentNames
percents
</code></pre>

<pre><code>##     0% 97.93% 97.94% 97.94% 97.95% 97.96% 97.98% 97.98% 97.99% 98.09% 
##     60     67      1      1      1      4      1      4      2      2 
## 98.32% 98.33% 98.34% 98.35% 98.36% 98.36%   100% 
##      1      1      2      1      4      2      6
</code></pre>

<p>The previous tables show no complete observations highly influenced by columns composed almost entirely of NA. Data imputation is ruled out for these columns.</p>

<pre><code class="r">dataset &lt;- dataset[colNAs == 0]

nonMeasures &lt;- 1:7
dataset &lt;- dataset[-nonMeasures]
dataset$classe &lt;- factor(dataset$classe)
</code></pre>

<p>Tree models will be used for this classification problem. Features such as timestamp, user and window are useless and might cause bias and should be removed.</p>

<p><strong>NOTE: Exercises were performed sequentially, so a timestamp or index (factor) value would bias the model.</strong></p>

<p>Final dataset has 52 numeric covariates, 1 factor target and 0 NA values. <strong>No further pre process is required. Transformation of variables with tree models has little to no effect.</strong></p>

<h2>Split Data</h2>

<p>I chose a 60%/20%/20% split for training, testing and validation sets. Training to create the model; Testing to select a model with best accuracy; Validation to estimate the Out of Sample Error.</p>

<pre><code class="r">set.seed(1961927)
inValidate &lt;- createDataPartition(dataset$classe, p = 0.2, list = FALSE)

validation &lt;- dataset[inValidate,]
dataset &lt;- dataset[-inValidate,]

inTrain &lt;- createDataPartition(dataset$classe, p = 0.75, list = FALSE)
training &lt;- dataset[inTrain,]
testing &lt;- dataset[-inTrain,]
</code></pre>

<h2>Exploratory Data Analysis</h2>

<p>All scatterplots of Xi vs Xj with classe as color were analyzed. All presented complex behaviors. 1326 plots were generated. I present only one of such plots.</p>

<p><img src="figure/All%20Scatterplots.png" alt="plot of chunk All Scatterplots"/> </p>

<p>The plot shows incorrect performances around the correct ones.</p>

<p><img src="figure/Corrplot%20and%20Heatmap%20on%20Scaled.png" alt="plot of chunk Corrplot and Heatmap on Scaled"/> </p>

<p>The heatmap on scaled data is difficult to read entirely and several columns appear as noise. However, multiple subgroups means there are observable differences and behaviors between samples and columns which a tree can take advantage of.</p>

<h2>Tree Models Selected</h2>

<p>I have chosen to use tree models listed below. </p>

<ul>
<li>CART (<code>rpart</code>)</li>
<li>RandomForest (<code>rf</code>)</li>
<li>Bagging Trees (<code>treebag</code>)</li>
<li>Gradient Boosting Machine (<code>gbm</code>)</li>
<li>Combined Estimation of All (Vote Mode)</li>
</ul>

<p>If I combine multiple models this way I should use an odd number of models. Worst case scenario however is that each model gets a different answer out of 5 possible. I should properly use at least 7 models. Computational limitations restrict me to 4. This should help avoid worst case scenario.</p>

<h2>Cross Validation (CV)</h2>

<p>Data is sorted by <code>classe</code> so K-Fold CV is not recommened because it would only study a handful of classes. Possible choices fall upon LOOCV and boot.</p>

<p>LOOCV is computationally intensive and boot can underestimate the error. We can adjust the latter with boot-632 and the validation set.</p>

<pre><code class="r">#controlTrain &lt;- trainControl(method = &#39;boot632&#39;, number = 25)
controlTrain &lt;- trainControl(method = &#39;boot632&#39;, number = 15)
#controlTrain &lt;- trainControl(method = &#39;repeatedcv&#39;, number=10, repeats=2)
</code></pre>

<p>Compute all models with training data.</p>

<pre><code class="r">modelCRT &lt;- train(classe ~ . , training, method = &#39;rpart&#39;, 
                  trControl = controlTrain)

#Faster RF execution, parallel multi thread
#cl &lt;- makePSOCKcluster(4)
#clusterEvalQ(cl, library(foreach))
#registerDoParallel(cl)
modelRFS &lt;- train(classe ~ . , training, method = &#39;rf&#39;, 
                  trControl = controlTrain)
#closeAllConnections()

modelBTS &lt;- train(classe ~ . , training, method = &#39;treebag&#39;, 
                  trControl = controlTrain)

#GBM Uses a lot of RAM (Breaking Execution, reduced it&#39;s tuning parameters)
gbmGrid &lt;-  expand.grid(n.trees = c(150), 
                        shrinkage=c(0.1),
                        interaction.depth=c(5))
modelGBM &lt;- train(classe ~ . , training, method = &#39;gbm&#39;, verbose = FALSE,
                  trControl = controlTrain, tuneGrid = gbmGrid)

models &lt;- list(CRT = modelCRT,
               RFS = modelRFS,
               BTS = modelBTS,
               GBM = modelGBM)
</code></pre>

<p>Model combination uses a custom mode function.</p>

<pre><code class="r">voteFN &lt;- function(predictions){
  #predictions &lt;- do.call(cbind, predictions)
  return(apply(predictions, 1, modeFN))
}

modeFN &lt;- function(values){
  temp &lt;- table(values)
  return(names(temp)[which.max(temp)])
}
</code></pre>

<p>Predictions are compute for each model over training, testing and validation sets.</p>

<pre><code class="r">#Training
trainPred &lt;- data.frame(real = training$classe)
trainPred$CRT &lt;- predict(modelCRT, newdata = training)
trainPred$RFS &lt;- predict(modelRFS, newdata = training)
trainPred$BTS &lt;- predict(modelBTS, newdata = training)
trainPred$GBM &lt;- predict(modelGBM, newdata = training)
trainPred$ALL &lt;- voteFN(trainPred[-1])

#Testing
testPred &lt;- data.frame(real = testing$classe)
testPred$CRT &lt;- predict(modelCRT, newdata = testing)
testPred$RFS &lt;- predict(modelRFS, newdata = testing)
testPred$BTS &lt;- predict(modelBTS, newdata = testing)
testPred$GBM &lt;- predict(modelGBM, newdata = testing)
testPred$ALL &lt;- voteFN(testPred[-1])

#Validation
validPred &lt;- data.frame(real = validation$classe)
validPred$CRT &lt;- predict(modelCRT, newdata = validation)
validPred$RFS &lt;- predict(modelRFS, newdata = validation)
validPred$BTS &lt;- predict(modelBTS, newdata = validation)
validPred$GBM &lt;- predict(modelGBM, newdata = validation)
validPred$ALL &lt;- voteFN(validPred[-1])
</code></pre>

<p>I use a custom accuracy evaluation.</p>

<pre><code class="r">MyAccuracy &lt;- function(preds){
  realValues &lt;- preds[,1]
  output &lt;- sapply(preds[-1], function(x) x == realValues)
  return(colSums(output)/nrow(preds))
}
</code></pre>

<p>I select the best model out of accuracy in testing set.</p>

<pre><code class="r">trainAcc &lt;- MyAccuracy(trainPred)
testAcc  &lt;- MyAccuracy(testPred)
validAcc &lt;- MyAccuracy(validPred)

#Find Maximum Accuracy Model on Testing Data
bestModelPos &lt;- which.max(testAcc)
bestModelName &lt;- names(testAcc)[bestModelPos]

#Error Estimation
AccuracyALL &lt;- data.frame(training = trainAcc, 
                          testing = testAcc, 
                          validation = validAcc)

#Accuracy for Best Model in Train / Test / Validation
AccuracyALL[bestModelPos,]
</code></pre>

<pre><code>##     training testing validation
## RFS        1  0.9916     0.9924
</code></pre>

<pre><code class="r"># Confusion Matrix of Best Model vs Real Test Classe
confusionMatrix(data = testPred[, bestModelPos + 1], 
                reference = testing$classe)$table
</code></pre>

<pre><code>##           Reference
## Prediction    A    B    C    D    E
##          A 1114    7    0    0    0
##          B    0  751    1    2    0
##          C    1    1  680   13    1
##          D    0    0    3  627    2
##          E    1    0    0    1  718
</code></pre>

<p>Best model was RFS which showed good results even taking into account that overfitting was high during training. It did well on testing and validation.</p>

<p><strong>Another model might seem more effective overall, but given Machine Learning concepts we can&#39;t change the model by considering the validation set &ldquo;part of the training or selection&rdquo;.</strong></p>

<p><img src="figure/All%20Accuracies%20Plot.png" alt="plot of chunk All Accuracies Plot"/> </p>

<p>I expected the ALL model to be better. It could be that CART or some other model affected it. For future reference, CART might be a bad choice for model combination with other more efficient models.</p>

<h2>Coursera Test</h2>

<p><strong>I expect the error rate on the Coursera 20 Values assigment to be closely similar to what I observed in my validation set, since it is a similar scenario and I obtained a near 100% accuracy on prediction.</strong></p>

<p>I proceed to load the Coursera testing data.</p>

<pre><code class="r">courseraTest &lt;- read.table(&#39;data/pml-testing.csv&#39;,
                           sep = &#39;,&#39;, 
                           header = TRUE, 
                           stringsAsFactors = FALSE, 
                           na.strings = c(&#39;&#39;,&#39;NA&#39;,&#39;#DIV/0!&#39;))
if(bestModelName == &#39;ALL&#39;){
  projectAnswers &lt;- lapply(models, function(x) predict(x, courseraTest))
  projectAnswers &lt;- do.call(cbind.data.frame, projectAnswers)
  projectAnswers &lt;- voteFN(projectAnswers)
}else{
  projectAnswers &lt;- predict(models[[bestModelName]], courseraTest)
  projectAnswers &lt;- as.character(projectAnswers)
}


pml_write_files(projectAnswers)
</code></pre>

<h2>Conclusions</h2>

<p>I can&#39;t compute the error for the Coursera Test set. I can only trust my work and model usage to behave similarly (although possible above or below it) as it did with the validation set (but the value should be lower than with the training set).</p>

<h2>Improvements</h2>

<ul>
<li><p>Change boot-632 with Stratified K Fold Cross Validation.</p></li>
<li><p>Explore more modeling options or machine learning algorithms, other tree ensembles or modified versions of the ones used in this document.</p></li>
</ul>

</body>

</html>

